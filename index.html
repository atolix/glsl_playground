<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GLSL Playground</title>

  <!-- PWA related settings -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#000000">

  <!-- CodeMirror CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.3/codemirror.min.css">
  <!-- Dracula theme removed as we're using custom GitHub Dark theme -->

  <!-- Custom CSS -->
  <link rel="stylesheet" href="style.css">

  <!-- CodeMirror JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.3/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.3/mode/clike/clike.min.js"></script>
</head>
<body>
  <div class="container">
    <div id="glCanvas"></div>
    <div class="control-panel" id="controlPanel">
      <div id="codeContainer" class="code-container">
        <div id="fragmentShader" class="tab-content active">
          <textarea id="fragmentCode">// This shader automatically adapts to WebGL1/WebGL2
// For WebGL2, #version 300 es will be automatically added at the beginning

// Shader variables
uniform vec2 u_resolution;
uniform float u_time;

// Output variable for WebGL2
// In WebGL2, out vec4 outColor; is used
// In WebGL1, gl_FragColor is used
out vec4 outColor;

float random (in float x) {
    return fract(sin(x)*1e4);
}

float random (in vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

float value_noise (in vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);

    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

// Improved FBM with rotation and movement
#define NUM_OCTAVES 8
float fbm (in vec2 _st, in float _time) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);

    // Animate rotation angle based on time with more variation
    float angle = 0.5 + 0.3 * sin(_time * 0.1) * cos(_time * 0.05);
    mat2 rot = mat2(cos(angle), sin(angle),
                   -sin(angle), cos(angle));

    for (int i = 0; i < NUM_OCTAVES; ++i) {
        v += a * value_noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

// Add a vortex distortion function
vec2 vortex(vec2 uv, vec2 center, float strength, float time) {
    vec2 delta = uv - center;
    float dist = length(delta);
    float angle = atan(delta.y, delta.x) + strength * smoothstep(0.0, 0.5, 0.5 - dist) * sin(time);
    float radius = dist + sin(dist * 8.0 + time) * 0.02;
    return center + vec2(cos(angle), sin(angle)) * radius;
}

void main(){
    vec2 uv = gl_FragCoord.xy / u_resolution;

    // Adjust aspect ratio
    uv.x *= u_resolution.x / u_resolution.y;

    // Create a breathing zoom effect
    float zoom = 1.0 + 0.1 * sin(u_time * 0.2);
    vec2 zoomed_uv = (uv - 0.5) / zoom + 0.5;

    // Apply a slow-moving vortex effect
    vec2 vortex_uv = vortex(zoomed_uv, vec2(0.5, 0.5), 0.5 + 0.2 * sin(u_time * 0.1), u_time * 0.2);

    // Add some subtle movement to base coordinates - more dynamic
    vec2 moving_uv = vortex_uv + vec2(
        sin(u_time * 0.1) * 0.1 + cos(u_time * 0.13 + uv.y * 5.0) * 0.03,
        cos(u_time * 0.08) * 0.1 + sin(u_time * 0.11 + uv.x * 5.0) * 0.03
    );

    vec3 color = vec3(0.0);

    // Add a wobble effect to the coordinates
    float wobble = sin(u_time * 0.7) * 0.02;
    moving_uv.x += wobble * sin(moving_uv.y * 10.0);
    moving_uv.y += wobble * cos(moving_uv.x * 10.0);

    // Initialize pattern coordinates with more variation
    vec2 q = vec2(0.);
    q.x = fbm(moving_uv + 0.1 * u_time, u_time);
    q.y = fbm(moving_uv + vec2(1.0, 0.3 + 0.1 * sin(u_time * 0.4)), u_time);

    vec2 r = vec2(0.);
    r.x = fbm(moving_uv + 1.0*q + vec2(1.7,1.2) + 0.15 * u_time, u_time);
    r.y = fbm(moving_uv + 1.0*q + vec2(8.3,2.8) + 0.126 * u_time, u_time + sin(u_time * 0.3));

    // Create dynamic wave patterns
    float wave1 = sin(uv.x * 10.0 + u_time * 0.5) * sin(uv.y * 8.0 + u_time * 0.7) * 0.01;
    float wave2 = sin(uv.x * 5.0 - u_time * 0.3) * sin(uv.y * 6.0 + u_time * 0.6) * 0.01;
    float wave3 = sin(length(uv - 0.5) * 15.0 - u_time * 0.8) * 0.01; // Circular wave

    // Combine all wave patterns with time-varying weights
    float waveWeight1 = 0.5 + 0.5 * sin(u_time * 0.2);
    float waveWeight2 = 0.5 + 0.5 * cos(u_time * 0.2);
    float wave = wave1 * waveWeight1 + wave2 * waveWeight2 + wave3 * (1.0 - waveWeight1 * waveWeight2);

    // Apply dynamic distortion to FBM coordinates
    float f = fbm(moving_uv + r + wave * 2.0, u_time);

    // Create color with original scheme but add time-based hue shift
    float hueShift = sin(u_time * 0.1) * 0.1;

    // Create animating color scheme
    vec3 color1 = vec3(1.0, 0.1333 + hueShift, 0.8275 - hueShift);  // Pink with shift
    vec3 color2 = vec3(0.9451, 0.7647 + sin(u_time * 0.3) * 0.1, 1.0 - sin(u_time * 0.3) * 0.1);  // Light purple with animation
    vec3 color3 = vec3(0.2588 + cos(u_time * 0.25) * 0.1, 0.9922, 0.9922 - cos(u_time * 0.25) * 0.1);  // Cyan with animation

    color = mix(vec3(1.0, 1.0, 1.0),
                color1,
                clamp((f*f)*4.0,0.0,1.0));

    color = mix(color,
                color2,
                clamp(length(q),0.0,1.0));

    color = mix(color,
                color3,
                clamp(length(r.x),0.0,1.0));

    // Add animated color bands based on position
    color += 0.05 * sin(uv.y * 20.0 + u_time * 2.0) * sin(u_time * 0.5);

    // Add dynamic flashes of light
    color += vec3(0.2, 0.2, 0.3) * max(0.0, sin(u_time * 2.0) - 0.8) * (1.0 - length(uv - 0.5));

    // Add subtle pulsing to the final color with varying frequency
    float pulseSpeed = 0.2 + 0.8 * abs(sin(u_time * 0.05));
    float pulse = 1.0 + 0.1 * sin(u_time * pulseSpeed);
    color *= pulse;

    // Final color with enhanced formula for more contrast
    outColor = vec4((f*f*f+.6*f*f+.5*f + 0.1 * sin(u_time * 0.3))*color,1.0);
}
          </textarea>
        </div>
      </div>
      <div class="buttons">
        <button onclick="toggleShader()">Play</button>
        <button onclick="toggleCode()">Hide Editor</button>
      </div>
    </div>
  </div>

  <!-- Custom JavaScript -->
  <script src="glsl_script.js"></script>

  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('sw.js').then(function(registration) {
          console.log('ServiceWorker registration successful: ', registration.scope);
        }, function(err) {
          console.log('ServiceWorker registration failed: ', err);
        });
      });
    }
  </script>
</body>
</html>
